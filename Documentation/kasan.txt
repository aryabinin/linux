Kernel address sanitizer
================

0. Overview
===========

Address sanitizer for kernel (KASAN) is a dynamic memory error detector. It provides
fast and comprehensive solution for finding use-after-free and out-of-bounds bugs.

KASAN is better than all of CONFIG_DEBUG_PAGEALLOC, because it:
 - is based on compiler instrumentation (fast),
 - detects OOB for both writes and reads,
 - provides UAF detection,
 - prints informative reports.

KASAN uses compiler instrumentation for checking every memory access, therefore you
will need a special compiler: GCC >= 4.10.0.

Currently KASAN supported on x86/x86_64/arm architectures and requires kernel
to be build with SLUB allocator.

1. Usage
=========

KASAN requires the kernel to be built with a special compiler (GCC >= 4.10.0).

To enable KASAN configure kernel with:

	  CONFIG_KASAN = y

to instrument entire kernel:

	  CONFIG_KASAN_SANTIZE_ALL = y

Currently KASAN works only with SLUB. It is highly recommended to run KASAN with
CONFIG_SLUB_DEBUG=y and 'slub_debug=U'. This enables user tracking (free and alloc traces).
There is no need to enable redzoning since KASAN detects access to user tracking structs
so they actually act like redzones.

To enable instrumentation for only specific files or directories, add a line
similar to the following to the respective kernel Makefile:

        For a single file (e.g. main.o):
                KASAN_SANITIZE_main.o := y

        For all files in one directory:
                KASAN_SANITIZE := y

To exclude files from being profiled even when CONFIG_GCOV_PROFILE_ALL
is specified, use:

                KASAN_SANITIZE_main.o := n
        and:
                KASAN_SANITIZE := n

Only files which are linked to the main kernel image or are compiled as
kernel modules are supported by this mechanism.


1.1 Error reports
==========

A typical buffer overflow report looks like this:

==================================================================
AddressSanitizer: buffer overflow in kasan_kmalloc_oob_rigth+0x6a/0x7a at addr c6006f1b
=============================================================================
BUG kmalloc-128 (Not tainted): kasan error
-----------------------------------------------------------------------------

Disabling lock debugging due to kernel taint
INFO: Allocated in kasan_kmalloc_oob_rigth+0x2c/0x7a age=5 cpu=0 pid=1
	__slab_alloc.constprop.72+0x64f/0x680
	kmem_cache_alloc+0xa8/0xe0
	kasan_kmalloc_oob_rigth+0x2c/0x7a
	kasan_tests_init+0x8/0xc
	do_one_initcall+0x85/0x1a0
	kernel_init_freeable+0x1f1/0x279
	kernel_init+0x8/0xd0
	ret_from_kernel_thread+0x21/0x30
INFO: Slab 0xc7f3d0c0 objects=14 used=2 fp=0xc6006120 flags=0x5000080
INFO: Object 0xc6006ea0 @offset=3744 fp=0xc6006d80

Bytes b4 c6006e90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
Object c6006ea0: 80 6d 00 c6 00 00 00 00 00 00 00 00 00 00 00 00  .m..............
Object c6006eb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
Object c6006ec0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
Object c6006ed0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
Object c6006ee0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
Object c6006ef0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
Object c6006f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
Object c6006f10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
CPU: 0 PID: 1 Comm: swapper/0 Tainted: G    B          3.16.0-rc3-next-20140704+ #216
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
 00000000 00000000 c6006ea0 c6889e30 c1c4446f c6801b40 c6889e48 c11c3f32
 c6006000 c6801b40 c7f3d0c0 c6006ea0 c6889e68 c11c4ff5 c6801b40 c1e44906
 c1e11352 c7f3d0c0 c6889efc c6801b40 c6889ef4 c11ccb78 c1e11352 00000286
Call Trace:
 [<c1c4446f>] dump_stack+0x4b/0x75
 [<c11c3f32>] print_trailer+0xf2/0x180
 [<c11c4ff5>] object_err+0x25/0x30
 [<c11ccb78>] kasan_report_error+0xf8/0x380
 [<c1c57940>] ? need_resched+0x21/0x25
 [<c11cb92b>] ? poison_shadow+0x2b/0x30
 [<c11cb92b>] ? poison_shadow+0x2b/0x30
 [<c11cb92b>] ? poison_shadow+0x2b/0x30
 [<c1f82763>] ? kasan_kmalloc_oob_rigth+0x7a/0x7a
 [<c11cbacc>] __asan_store1+0x9c/0xa0
 [<c1f82753>] ? kasan_kmalloc_oob_rigth+0x6a/0x7a
 [<c1f82753>] kasan_kmalloc_oob_rigth+0x6a/0x7a
 [<c1f8276b>] kasan_tests_init+0x8/0xc
 [<c1000435>] do_one_initcall+0x85/0x1a0
 [<c1f6f508>] ? repair_env_string+0x23/0x66
 [<c1f6f4e5>] ? initcall_blacklist+0x85/0x85
 [<c10c9883>] ? parse_args+0x33/0x450
 [<c1f6fdb7>] kernel_init_freeable+0x1f1/0x279
 [<c1000558>] kernel_init+0x8/0xd0
 [<c1c578c1>] ret_from_kernel_thread+0x21/0x30
 [<c1000550>] ? do_one_initcall+0x1a0/0x1a0
Write of size 1 by thread T1:
Memory state around the buggy address:
 c6006c80: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
 c6006d00: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
 c6006d80: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
 c6006e00: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
 c6006e80: fd fd fd fd 00 00 00 00 00 00 00 00 00 00 00 00
>c6006f00: 00 00 00 03 fc fc fc fc fc fc fc fc fc fc fc fc
                    ^
 c6006f80: fc fc fc fc fc fc fc fc fd fd fd fd fd fd fd fd
 c6007000: 00 00 00 00 00 00 00 00 00 fc fc fc fc fc fc fc
 c6007080: fc fc fc fc fc fc fc fc fc fc fc fc fc 00 00 00
 c6007100: 00 00 00 00 00 00 fc fc fc fc fc fc fc fc fc fc
 c6007180: fc fc fc fc fc fc fc fc fc fc 00 00 00 00 00 00
==================================================================

In the last section the report shows memory state around the accessed address.
Reading this part requires some more undestanding of how KASAN works.

Each KASAN_SHADOW_SCALE_SIZE bytes of memory can be marked as addressable,
partially addressable, freed or they can be part of a redzone.
If bytes are marked as addressable that means that they belong to some
allocated memory block and it is possible to read or modify any of these
bytes. Addressable KASAN_SHADOW_SCALE_SIZE bytes are marked by 0 in the report.
When only the first N bytes of KASAN_SHADOW_SCALE_SIZE belong to an allocated
memory block, this bytes are partially addressable and marked by 'N'.

Markers of unaccessible bytes could be found in mm/kasan/kasan.h header:

#define KASAN_FREE_PAGE         0xFF  /* page was freed */
#define KASAN_PAGE_REDZONE      0xFE  /* redzone for kmalloc_large allocations */
#define KASAN_SLAB_REDZONE      0xFD  /* Slab page redzone, does not belong to any slub object */
#define KASAN_KMALLOC_REDZONE   0xFC  /* redzone inside slub object */
#define KASAN_KMALLOC_FREE      0xFB  /* object was freed (kmem_cache_free/kfree) */
#define KASAN_SLAB_FREE         0xFA  /* free slab page */
#define KASAN_SHADOW_GAP        0xF9  /* address belongs to shadow memory */

In the report above the arrows point to the shadow byte 03, which means that the
accessed address is partially addressable.


2. Implementation details
========================

2.1. Shadow memory
==================

From a high level, our approach to memory error detection is similar to that
of kmemcheck: use shadow memory to record whether each byte of memory is safe
to access, and use instrumentation to check the shadow memory on each memory
access.

AddressSanitizer dedicates one-eighth of the low memory to its shadow
memory and uses direct mapping with a scale and offset to translate a memory
address to its corresponding shadow address.

Here is function witch translate address to corresponding shadow address:

unsigned long kasan_mem_to_shadow(unsigned long addr)
{
	return ((addr - PAGE_OFFSET) >> KASAN_SHADOW_SCALE_SHIFT) + KASAN_SHADOW_START;
}

where KASAN_SHADOW_SCALE_SHIFT = 3.

The figure below shows the address space layout. The memory is split
into two parts (low and high) which map to the corresponding shadow regions.
Applying the shadow mapping to addresses in the shadow region gives us
addresses in the Bad region.

|--------|        |--------|
| Memory |----    | Memory |
|--------|    \   |--------|
| Shadow |--   -->| Shadow |
|--------|  \     |--------|
|   Bad  |   ---->|  Bad   |
|--------|  /     |--------|
| Shadow |--   -->| Shadow |
|--------|    /   |--------|
| Memory |----    | Memory |
|--------|        |--------|

Each shadow byte corresponds to 8 bytes of the main memory. We use the
following encoding for each shadow byte: 0 means that all 8 bytes of the
corresponding memory region are addressable; k (1 <= k <= 7) means that
the first k bytes are addressable, and other (8 - k) bytes are not;
any negative value indicates that the entire 8-byte word is unaddressable.
We use different negative values to distinguish between different kinds of
unaddressable memory (redzones, freed memory) (see mm/kasan/kasan.h).

Poisoning or unpoisoning a byte in the main memory means writing some special
value into the corresponding shadow memory. This value indicates whether the
byte is addressable or not.


2.2. Instrumentation
====================

Since some functions (such as memset, memmove, memcpy) wich do memory accesses
are written in assembly, compiler can't instrument them.
Therefore we replace these functions with our own instrumented functions
(kasan_memset, kasan_memcpy, kasan_memove).
In some circumstances you may need to use the original functions,
in such case insert #undef KASAN_HOOKS before includes.

