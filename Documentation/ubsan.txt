Undefined Behavior Sanitizer - UBSan

Overview
========

UBSan is a runtime undefined behaviour checker.

UBSan uses compile-time instrumentation to catch undefined behavior (UB).
Compiler inserts code that perform certain kinds of checks before operations
that may cause UB. If check fails (i.e. UB detected) __ubsan_handle_*
function called to print error message.

GCC has that feature since 4.9 [1] (see -fsanitize=undefined option and its suboptions).
Upcoming GCC 5.0 has more checkers implemented [2].

Usage
=======

To enable UBSAN configure kernel with:

	  CONFIG_UBSAN=y

and to check the entire kernel:

        CONFIG_UBSAN_SANITIZE_ALL=y

To enable instrumentation for specific files or directories, add a line
similar to the following to the respective kernel Makefile:

        For a single file (e.g. main.o):
                UBSAN_SANITIZE_main.o := y

        For all files in one directory:
                UBSAN_SANITIZE := y

To exclude files from being instrumented even if CONFIG_UBSAN_SANITIZE_ALL=y,
use:

                UBSAN_SANITIZE_main.o := n
        and:
                UBSAN_SANITIZE := n

Various types of checkers may be enabled via boot parameter, e.g.:
     ubsan_handle=OEAINVBSLU

Possible options are:
        O - different kinds of integer overflows
        E - negation overflow, division overflow, division by zero.
        A - misaligned memory access.
        I - load from/store to an object with insufficient space.
        N - passing NULL as argument declared with nonnull attribute,
             returned null from function which never returns null,
             null ptr dereference.
        V - variable size array with non-positive length
        B - out-of-bounds memory accesses
        S - shifting out-of-bounds
        L - load of invalid value (value out of range for the enum type,
              loading other then 0/1 to bool type)
        U - __builtin_unreachable() was called

If ubsan_handle not present in cmdline the default options are used: ELNVBSLU.
Additionally option 'A' (misaligned access checks) enabled by default if
architecture doesn't support unaligned accesses.

References
==========

[1] - https://gcc.gnu.org/onlinedocs/gcc-4.9.0/gcc/Debugging-Options.html
[2] - https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html
